<!DOCTYPE html><html lang="en"><head><title>MultiDiGraph</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="MultiDiGraph"><meta name="groc-project-path" content="js/src/MultiDiGraph.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-adjacency-list"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-adjacency-list/blob/master/js/src/MultiDiGraph.js">js/src/MultiDiGraph.js</a></div></div><div id="document"><div class="segment"></div><div class="segment"><div class="comments "><div class="wrapper"><p>Complexity of each update operation in comments for
classical Doubly Linked List and Hash Map implementations.
Complexity in O(.) notation is most likely amortized time
for operation involving the successors and predecessors maps.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> MultiDiGraph = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> List , Map </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(1)</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">const</span> Graph = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> </span>) </span>{

		<span class="hljs-keyword">this</span>.V = <span class="hljs-keyword">new</span> List( ) ;

		<span class="hljs-keyword">this</span>.succ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>( ) ;
		<span class="hljs-keyword">this</span>.pred = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>( ) ;

	} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(1)</p></div></div><div class="code"><div class="wrapper">	Graph.prototype.vadd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> </span>) </span>{

		<span class="hljs-keyword">const</span> v = <span class="hljs-keyword">new</span> DiVertex( ) ;

		<span class="hljs-keyword">this</span>.succ.set( v , <span class="hljs-keyword">new</span> List( ) ) ;
		<span class="hljs-keyword">this</span>.pred.set( v , <span class="hljs-keyword">new</span> List( ) ) ;

		v.iterator = <span class="hljs-keyword">this</span>.V.push( v ) ;

		<span class="hljs-keyword">return</span> v ;

	} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(n) where n is the degree of v</p></div></div><div class="code"><div class="wrapper">	Graph.prototype.vdel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> v </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>remove all ingoing and outgoing edges</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span>  <span class="hljs-keyword">this</span>.initr( v ) ) <span class="hljs-keyword">this</span>.edel( e ) ;
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.outitr( v ) ) <span class="hljs-keyword">this</span>.edel( e ) ;

		<span class="hljs-keyword">this</span>.pred.delete( v ) ;
		<span class="hljs-keyword">this</span>.succ.delete( v ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>remove vertex</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.V.erase( v.iterator ) ;

	} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(1)</p></div></div><div class="code"><div class="wrapper">	Graph.prototype.eadd = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> u , v </span>) </span>{

		<span class="hljs-keyword">const</span> uv = <span class="hljs-keyword">new</span> DiEdge( u , v , <span class="hljs-keyword">this</span>.succ ) ;
		<span class="hljs-keyword">const</span> vu = <span class="hljs-keyword">new</span> DiEdge( v , u , <span class="hljs-keyword">this</span>.pred ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>add to edge list of u</p></div></div><div class="code"><div class="wrapper">		uv.iterator = <span class="hljs-keyword">this</span>.succ.get( u ).push( uv ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>add to edge list of v</p></div></div><div class="code"><div class="wrapper">		vu.iterator = <span class="hljs-keyword">this</span>.pred.get( v ).push( vu ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set twin</p></div></div><div class="code"><div class="wrapper">		uv.twin = vu ;
		vu.twin = uv ;

		<span class="hljs-keyword">return</span> uv ;

	} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(1)</p></div></div><div class="code"><div class="wrapper">	Graph.prototype.edel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> e </span>) </span>{

		e.list.erase( e.iterator ) ;
		e.twin.list.erase( e.twin.iterator ) ;

	} ;


	Graph.prototype.vitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> </span>) </span>{

		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.V ;

	} ;

	Graph.prototype.eitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> </span>) </span>{

		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> [ _ , edges ] <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.succ ) <span class="hljs-keyword">yield</span>* edges ;

	} ;

	Graph.prototype.iitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> v </span>) </span>{

		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.initr( v ) ;
		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.outitr( v ) ;

	} ;

	Graph.prototype.initr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> v </span>) </span>{

		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.pred.get( v ) ;

	} ;

	Graph.prototype.outitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> v </span>) </span>{

		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.succ.get( v ) ;

	} ;

	Graph.prototype.nitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> u </span>) </span>{

		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.dsitr( u ) ;
		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.dpitr( u ) ;

	} ;

	Graph.prototype.dsitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> u </span>) </span>{

		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> { v } <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.succ.get( u ) ) <span class="hljs-keyword">yield</span> v ;

	} ;

	Graph.prototype.dpitr = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> u </span>) </span>{

		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> { v } <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.pred.get( u ) ) <span class="hljs-keyword">yield</span> v ;

	} ;

	Graph.prototype.edges = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> </span>) </span>{

		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.eitr( ) ) <span class="hljs-keyword">yield</span> [ e.u , e.v , e ] ;

	} ;

	Graph.prototype.incident = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> u </span>) </span>{

		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.ingoing( u ) ;
		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.outgoing( u ) ;

	} ;

	Graph.prototype.ingoing = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> u </span>) </span>{

		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.initr( u ) ) <span class="hljs-keyword">yield</span> [ e.u , e.v , e ] ;

	} ;

	Graph.prototype.outgoing = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> u </span>) </span>{

		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">let</span> e <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.outitr( u ) ) <span class="hljs-keyword">yield</span> [ e.u , e.v , e ] ;

	} ;


	Graph.prototype.endpoints = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> e </span>) </span>{

		<span class="hljs-keyword">return</span> [ e.u , e.v ] ;

	} ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>O(1)</p></div></div><div class="code"><div class="wrapper">	Graph.prototype.reverse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> </span>) </span>{

		[ <span class="hljs-keyword">this</span>.succ , <span class="hljs-keyword">this</span>.pred ] = [ <span class="hljs-keyword">this</span>.pred , <span class="hljs-keyword">this</span>.succ ] ;

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> ;

	} ;

	<span class="hljs-keyword">return</span> Graph ;

} ;

exports.MultiDiGraph = MultiDiGraph ;</div></div></div></div></body></html>